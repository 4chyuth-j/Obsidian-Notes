
# üöÄObject methods
### **Defining Object Methods**

You can define methods in an object using **function expressions**, **ES6 shorthand**, or **arrow functions**.

#### **1. Using Function Expression**

```js
const person = {
  name: "Achyuth",
  greet: function () {
    return "Hello, " + this.name;
  }
};

console.log(person.greet()); // Output: Hello, Achyuth
```

#### **2. Using ES6 Method Shorthand**

```js
const person = {
  name: "Achyuth",
  greet() {
    return `Hello, ${this.name}`;
  }
};

console.log(person.greet()); // Output: Hello, Achyuth
```

#### **3. Using Arrow Functions (Not Recommended for Methods)**

Arrow functions **don't bind** `this` to the object.

```js
const person = {
  name: "Achyuth",
  greet: () => `Hello, ${this.name}` // `this` refers to global scope, not `person`
};

console.log(person.greet()); // Output: Hello, undefined
```

This happens because arrow functions **do not have their own `this`**.

---

### **Common Built-in Object Methods**

#### **1. Object.keys()** ‚Äì Returns an array of object‚Äôs keys

```js
const obj = { a: 1, b: 2, c: 3 };
console.log(Object.keys(obj)); // Output: ['a', 'b', 'c']
```

#### **2. Object.values()** ‚Äì Returns an array of object‚Äôs values

```js
console.log(Object.values(obj)); // Output: [1, 2, 3]
```

#### **3. Object.entries()** ‚Äì Returns an array of key-value pairs

```js
console.log(Object.entries(obj)); // Output: [['a', 1], ['b', 2], ['c', 3]]
```

#### **4. Object.assign()** ‚Äì Copies properties from one or more objects to a target object

```js
const target = { a: 1 };
const source = { b: 2, c: 3 };
Object.assign(target, source);
console.log(target); // Output: { a: 1, b: 2, c: 3 }
```

#### **5. Object.freeze()** ‚Äì Prevents modification of an object

```js
const obj1 = { a: 1 };
Object.freeze(obj1);
obj1.a = 100; // No effect
console.log(obj1.a); // Output: 1
```

#### **6. Object.seal()** ‚Äì Allows modification of properties but prevents adding or deleting properties

```js
const obj2 = { a: 1 };
Object.seal(obj2);
obj2.a = 100; // Works
obj2.b = 200; // No effect
console.log(obj2); // Output: { a: 100 }
```

#### **7. Object.hasOwnProperty()** ‚Äì Checks if a property exists in an object

```js
console.log(obj.hasOwnProperty("a")); // Output: true
console.log(obj.hasOwnProperty("z")); // Output: false
```

---

### **Custom Object Methods Example**

```js
const calculator = {
  num1: 10,
  num2: 5,
  add() {
    return this.num1 + this.num2;
  },
  subtract() {
    return this.num1 - this.num2;
  }
};

console.log(calculator.add());      // Output: 15
console.log(calculator.subtract()); // Output: 5
```

# üöÄObject.freeze() and Object.seal()

## ‚úÖ **1Ô∏è‚É£ `Object.freeze()`**

### What it does:

- Makes **the entire object immutable**:
    
    - You **cannot add** new properties.
        
    - You **cannot remove** existing properties.
        
    - You **cannot change** existing property values.
        
    - You **cannot change property descriptors** (writable, configurable).
        

### Example:

```js
const obj = { name: "Achyuth", age: 24 };
Object.freeze(obj);

obj.age = 25;        // ‚ùå No change
obj.city = "Kollam"; // ‚ùå Cannot add
delete obj.name;     // ‚ùå Cannot delete

console.log(obj); // { name: "Achyuth", age: 24 }
```

---

## ‚úÖ **2Ô∏è‚É£ `Object.seal()`**

### What it does:

- **Prevents adding or removing properties**.
    
- You **can still modify the values** of existing properties.
    
- Properties remain **writable** but **not configurable**.
    
- You **cannot change property attributes** (cannot make a property non-enumerable or non-writable).
    

### Example:

```js
const obj = { name: "Achyuth", age: 24 };
Object.seal(obj);

obj.age = 25;        // ‚úÖ Allowed
obj.city = "Kollam"; // ‚ùå Cannot add
delete obj.name;     // ‚ùå Cannot delete

console.log(obj); // { name: "Achyuth", age: 25 }
```

---

## ‚úÖ **Key Differences Table**

|Feature|`Object.freeze()`|`Object.seal()`|
|---|---|---|
|Add properties|‚ùå Not allowed|‚ùå Not allowed|
|Remove properties|‚ùå Not allowed|‚ùå Not allowed|
|Modify existing values|‚ùå Not allowed|‚úÖ Allowed|
|Change property descriptors|‚ùå Not allowed|‚ùå Not allowed|
|Makes object fully immutable|‚úÖ Yes|‚ùå No (values can change)|

---

## ‚úÖ Checking if an object is frozen or sealed:

- Check if **frozen:**
    

```js
Object.isFrozen(obj); // true / false
```

- Check if **sealed:**
    

```js
Object.isSealed(obj); // true / false
```

---

## üö© **Summary:**

‚úÖ Use **`Object.freeze()`** when you want **full immutability** of the object.  
‚úÖ Use **`Object.seal()`** when you want to **prevent adding/removing properties but allow value modifications.**

---

If you want, I can prepare **practice code snippets for deep cloning + freezing or sealing objects** to build your foundational JS mastery further. Let me know!

# üöÄType Casting in JavaScript

Type casting (also known as **type conversion**) is the process of converting a value from one data type to another. In JavaScript, this can happen **implicitly (coercion)** or **explicitly (manual conversion).**

---

## **1. Implicit Type Casting (Type Coercion)**

JavaScript automatically converts values when needed.

### **Example 1: String + Number ‚Üí String**

```js
console.log("5" + 3);  // "53" (Number converted to String)
console.log("5" + true); // "5true" (Boolean converted to String)
```

### **Example 2: String - Number ‚Üí Number**

```js
console.log("5" - 3);  // 2 (String converted to Number)
console.log("10" * 2); // 20 (String converted to Number)
console.log("5" - true); // 4 (true is 1, so "5" - 1 = 4)
```

### **Example 3: Boolean to Number**

```js
console.log(true + 1);  // 2 (true is 1)
console.log(false + 1); // 1 (false is 0)
```

---

## **2. Explicit Type Casting (Manual Conversion)**

You can manually convert data types using JavaScript methods.

### **Convert to String**

- `String(value)` or `value.toString()`

```js
console.log(String(123));    // "123"
console.log((123).toString()); // "123"
console.log(String(true));   // "true"
console.log(String(null));   // "null"
```

### **Convert to Number**

- `Number(value)` or `parseInt(value)` / `parseFloat(value)`

```js
console.log(Number("123"));    // 123
console.log(Number("123abc")); // NaN (Not a Number)
console.log(parseInt("123abc")); // 123 (Extracts only numbers)
console.log(parseFloat("10.5px")); // 10.5
console.log(Number(true));    // 1
console.log(Number(false));   // 0
console.log(Number(null));    // 0
console.log(Number(undefined)); // NaN
```

### **Convert to Boolean**

- `Boolean(value)`

```js
console.log(Boolean(1));  // true
console.log(Boolean(0));  // false
console.log(Boolean("hello"));  // true
console.log(Boolean(""));  // false
console.log(Boolean(null));  // false
console.log(Boolean(undefined));  // false
```

---

## **3. Special Cases**

```js
console.log(5 + null);    // 5 (null is converted to 0)
console.log("5" + null);  // "5null" (null is converted to "null")
console.log("5" - null);  // 5 (null is converted to 0)
console.log(undefined + 1); // NaN (undefined can't be converted)
console.log("5" * "2"); // 10 (Both strings converted to numbers)
```



# üöÄHoisting 

##  What is Hoisting?

**Hoisting** is JavaScript‚Äôs default behavior of **moving declarations to the top of their scope (global or function) before code execution.**

‚úÖ Only **declarations are hoisted**, **not initializations**.

---

## ‚úÖ **1Ô∏è‚É£ Variable Hoisting**

### Using `var`:

```js
console.log(a); // undefined (not ReferenceError)
var a = 10;
```

### What actually happens internally:

```js
var a;
console.log(a); // undefined
a = 10;
```

‚úÖ **`var` declarations are hoisted and initialized with `undefined`.**

---

### Using `let` and `const`:

```js
console.log(b); // ‚ùå ReferenceError: Cannot access 'b' before initialization
let b = 20;
```

‚úÖ `let` and `const` are **hoisted but not initialized**.  
‚úÖ They remain in the **Temporal Dead Zone (TDZ)** from the start of the block until the line where they are initialized.

---

## ‚úÖ **2Ô∏è‚É£ Function Hoisting**

### Function Declarations:

```js
greet(); // ‚úÖ Works

function greet() {
  console.log("Hello!");
}
```

‚úÖ Function declarations are **fully hoisted** (both name and body).

---

### Function Expressions:

```js
sayHi(); // ‚ùå TypeError: sayHi is not a function

var sayHi = function() {
  console.log("Hi!");
}
```

Here, `var sayHi` is hoisted and initialized as `undefined`, but the **function definition is not hoisted**.

---

## ‚úÖ **3Ô∏è‚É£ Summary Table**

|Item|Hoisted|Initialized|
|---|---|---|
|`var`|‚úÖ Yes|‚úÖ `undefined`|
|`let`, `const`|‚úÖ Yes|‚ùå No (TDZ)|
|Function declarations|‚úÖ Yes|‚úÖ Yes|
|Function expressions (`var sayHi = function() {}`)|‚úÖ Variable only|‚ùå No|

---

## ‚úÖ **Practical Example:**

```js
function test() {
  console.log(a); // undefined
  var a = 5;
  console.log(a); // 5

  console.log(b); // ReferenceError
  let b = 10;
}
test();
```

---

## üö© Why it matters:

‚úÖ Understanding hoisting helps avoid bugs when accessing variables before they are declared.  
‚úÖ Helps clarify differences between `var`, `let`, `const`, and function handling in memory during execution.

# üöÄTemporal Dead Zone(TDZ)

## What is **Temporal Dead Zone (TDZ)?**

The **Temporal Dead Zone** is the period between:

‚úÖ The **start of the block scope** (where the variable is hoisted), and  
‚úÖ The **line where the variable is initialized**,

during which accessing the variable will throw a **ReferenceError**.

---

‚úÖ **It applies to `let` and `const`.**  
‚úÖ It **does not apply to `var`** (since `var` is hoisted and initialized with `undefined`).

---

## ‚úÖ **Example:**

```js
{
    console.log(a); // ‚ùå ReferenceError: Cannot access 'a' before initialization
    let a = 10;
    console.log(a); // ‚úÖ 10
}
```

**Explanation:**

- `let a` is **hoisted** to the top of the block scope.
    
- However, it is **not initialized** until `let a = 10;` is executed.
    
- Between the start of the block and the initialization, `a` is in the **Temporal Dead Zone**.
    

---

## ‚úÖ **Another example with `const`:**

```js
{
    console.log(b); // ‚ùå ReferenceError
    const b = 20;
}
```

‚úÖ Same TDZ behavior applies to `const`.

---

## ‚úÖ **Example with `var` (no TDZ):**

```js
{
    console.log(c); // ‚úÖ undefined
    var c = 30;
    console.log(c); // ‚úÖ 30
}
```

‚úÖ `var` is hoisted and initialized with `undefined`, so **no TDZ**.

---

## ‚úÖ **Visual Understanding:**

```js
{
    // TDZ starts here for `x`
    let x = 5; // TDZ ends here
}
```

During the TDZ, **you cannot access or use the variable**.

---

## ‚úÖ **Why was TDZ introduced?**

- To **catch errors early** (e.g., using variables before declaring them).
    
- To support **block scoping** cleanly with `let` and `const`.
    
- To avoid unexpected behaviors seen with `var` hoisting.
    

---

## ‚úÖ **Summary Table:**

|Behavior|`var`|`let` / `const`|
|---|---|---|
|Hoisted|‚úÖ Yes|‚úÖ Yes|
|Initialized|‚úÖ `undefined`|‚ùå No|
|Can access before initialization|‚úÖ Yes|‚ùå No (TDZ)|
|Error if accessed before initialization|‚ùå No|‚úÖ ReferenceError|

# üöÄ Callback

## **What is a Callback?**

A **callback** is **a function passed as an argument to another function** so that it can be executed **after some operation is completed**.

‚úÖ It **‚Äúcalls back‚Äù** when the operation finishes.

‚úÖ **It enables asynchronous and modular behavior** in JavaScript.

---

## ‚úÖ **Simple Example:**

```js
function greet(name, callback) {
    console.log("Hello " + name);
    callback();
}

function sayBye() {
    console.log("Goodbye!");
}

greet("Achyuth", sayBye);
```

**Output:**

```
Hello Achyuth
Goodbye!
```

‚úÖ Here, `sayBye` is a **callback function**, executed **after `greet` prints "Hello Achyuth".**

---

## ‚úÖ **Real-world Example: Using `setTimeout`**

```js
console.log("Start");

setTimeout(function() {
    console.log("Executed after 2 seconds");
}, 2000);

console.log("End");
```

**Output:**

```
Start
End
Executed after 2 seconds
```

‚úÖ The **function passed to `setTimeout` is a callback**, executed **after 2 seconds**, demonstrating **asynchronous behavior**.

---

## ‚úÖ **Callback with Array Methods**

Many array methods use callbacks internally.

**Example: `forEach`:**

```js
const arr = [1, 2, 3];

arr.forEach(function(num) {
    console.log(num * 2);
});
```

**Output:**

```
2
4
6
```

‚úÖ The function inside `forEach` is a callback executed for each element.

---

## ‚úÖ **Why are Callbacks Important?**

‚úÖ Allow **asynchronous operations** (network requests, reading files, timers).  
‚úÖ Enable **modular, reusable code**.  
‚úÖ Are the foundation for **event handling** in browsers (`onclick`, `onsubmit` handlers).

---

## üö© **Problems with Callbacks: Callback Hell**

Nested callbacks can lead to:

```js
doTask1(function() {
    doTask2(function() {
        doTask3(function() {
            // ...
        });
    });
});
```

‚ùå This is called **callback hell** and makes code hard to read.

‚úÖ Modern JavaScript uses **Promises and `async/await`** to handle asynchronous operations more cleanly.

---

## ‚úÖ **Summary:**

‚úÖ A **callback is a function passed to another function to execute later.**  
‚úÖ Used heavily in **asynchronous programming** in JavaScript.  
‚úÖ Enables modular, non-blocking behavior in your projects.

---

If you want, I can prepare **callback practice problems (file reading, API simulation, or event handling) for hands-on clarity** to strengthen your JS skill. Let me know!

# üöÄJavaScript Event Loop 

The Event Loop is what makes JavaScript asynchronous and non-blocking, allowing it to handle multiple tasks efficiently despite being single-threaded.

---

## üîπ How JavaScript Works Behind the Scenes?

JavaScript uses:

1. Call Stack (Executes synchronous code)
    
2. Web APIs (Handles async tasks like setTimeout, fetch, etc.)
    
3. Callback Queue (Stores callbacks from async tasks)
    
4. Microtask Queue (Stores promises & other high-priority tasks)
    
5. Event Loop (Manages execution order)
    

---

## üîπ How the Event Loop Works?

1Ô∏è‚É£ Synchronous code runs first (placed in the Call Stack).  
2Ô∏è‚É£ Async tasks (like setTimeout or fetch) move to Web APIs.  
3Ô∏è‚É£ Once completed, their callbacks go to the Callback Queue.  
4Ô∏è‚É£ Promises & high-priority tasks go to the Microtask Queue.  
5Ô∏è‚É£ The Event Loop keeps checking the Call Stack:

- If the Call Stack is empty, it moves the next task from the Microtask Queue first.
    
- If no microtasks remain, it moves a task from the Callback Queue.
    

---

## üîπ Example: How the Event Loop Works

```js
console.log("1Ô∏è‚É£ Start");¬† // Runs first (Synchronous)

setTimeout(() => {
¬†¬†¬†¬†console.log("3Ô∏è‚É£ Timeout callback");¬† // Runs later (Async)
}, 0);

Promise.resolve().then(() => console.log("2Ô∏è‚É£ Promise resolved")); // Microtask (Higher Priority)

console.log("4Ô∏è‚É£ End"); // Runs second (Synchronous)
```

  

### üîç Output

1Ô∏è‚É£ Start

4Ô∏è‚É£ End

2Ô∏è‚É£ Promise resolved¬† ‚úÖ (Microtasks run before Callback Queue)

3Ô∏è‚É£ Timeout callback

  

‚úî Why? Even though setTimeout has 0ms, it waits in the Callback Queue until synchronous & microtasks are done.

---

## üìå Key Takeaways

|   |   |
|---|---|
|Concept|Explanation|
|Call Stack|Executes synchronous code (line by line).|
|Web APIs|Handles async tasks (setTimeout, fetch, etc.).|
|Callback Queue|Stores async callbacks (runs after Microtasks).|
|Microtask Queue|Stores Promises (higher priority than Callback Queue).|
|Event Loop|Keeps checking the Call Stack and moves tasks from queues.|

---


# **üöÄArrow Functions in JavaScript (`=>`)**

An **arrow function** is a shorter way to write functions in JavaScript, introduced in **ES6**. It is especially useful for **concise function expressions** and **lexical `this` binding**.

---

## **üîπ Syntax of Arrow Functions**

### **‚úÖ Basic Syntax**

```js
const functionName = (param1, param2) => expression;
```

- No need for `function` keyword.
- **`return` is implicit** for one-line expressions.

---

## **üîπ Examples of Arrow Functions**

### **‚úÖ Example 1: Regular Function vs Arrow Function**

```js
// Regular Function
function add(a, b) {
    return a + b;
}

// Arrow Function
const addArrow = (a, b) => a + b;

console.log(add(2, 3));       // 5
console.log(addArrow(2, 3));  // 5
```

‚úîÔ∏è **Shorter & cleaner syntax** with an **implicit return**.

---

### **‚úÖ Example 2: Arrow Function with One Parameter**

```js
const square = x => x * x;  // No need for parentheses with one parameter
console.log(square(5));      // 25
```

‚úîÔ∏è **Parentheses around a single parameter can be omitted**.

---

### **‚úÖ Example 3: Arrow Function with No Parameters**

```js
const greet = () => "Hello, World!";
console.log(greet());  // "Hello, World!"
```

‚úîÔ∏è **If no parameters, use `()`**.

---

### **‚úÖ Example 4: Arrow Function with Multiple Statements**

```js
const multiply = (a, b) => {
    console.log(`Multiplying ${a} and ${b}`);
    return a * b;
};
console.log(multiply(3, 4));  // 12
```

‚úîÔ∏è **For multiple lines, `{}` and `return` are required**.

---

## **üîπ Differences Between Arrow Functions & Regular Functions**

|Feature|Arrow Function (`=>`)|Regular Function (`function`)|
|---|---|---|
|**Syntax**|Shorter & cleaner|More verbose|
|**`this` binding**|**Lexically binds `this`** (inherits from surrounding scope)|**Has its own `this`**|
|**Implicit Return**|**Yes** (for one-liners)|**No**, must use `return`|
|**Usable as a Constructor?**|‚ùå No|‚úÖ Yes|
|**Hoisting**|‚ùå No (must be declared before use)|‚úÖ Yes (function declarations are hoisted)|

---

## **üîπ Example: `this` Behavior in Arrow vs Regular Functions**

```js
const person = {
    name: "Achyuth",
    regularFunction: function() {
        console.log("Regular:", this.name);
    },
    arrowFunction: () => {
        console.log("Arrow:", this.name);
    }
};

person.regularFunction();  // "Regular: Achyuth"
person.arrowFunction();    // "Arrow: undefined"
```

‚úîÔ∏è **Arrow functions do not have their own `this`, they inherit from the surrounding scope**.

---

## **üöÄ When to Use Arrow Functions?**

‚úîÔ∏è **Good for:**

- **Short functions**
- **Callbacks (`map, filter, reduce`)**
- **Avoiding `this` confusion**

‚ùå **Avoid for:**

- **Object methods** (since `this` won't refer to the object)
- **Constructors** (cannot use `new`)

# **üöÄUnderstanding `this` Binding in Arrow vs Regular Functions 

In JavaScript, **`this` refers to the object that is calling the function**. However, how `this` is determined depends on whether you're using a **regular function** or an **arrow function**.

---

## **üîπ `this` in Regular Functions (`function`)**

- A **regular function** creates its **own `this`**.
- The value of `this` **depends on how the function is called**.

### **‚úÖ Example 1: Regular Function in an Object**

```js
const person = {
    name: "Achyuth",
    greet: function() {
        console.log("Hello, " + this.name);
    }
};

person.greet();  // "Hello, Achyuth"
```

‚úîÔ∏è **Here, `this` refers to `person` because `greet()` is called on `person`**.

---

### **‚úÖ Example 2: Losing `this` in a Regular Function**

```js
const person = {
    name: "Achyuth",
    greet: function() {
        setTimeout(function() {
            console.log("Hello, " + this.name);
        }, 1000);
    }
};

person.greet();  
// Output: "Hello, undefined" (or "Hello, " in browsers)
```

‚ùå **Problem:** `this` inside `setTimeout` refers to the global object (`window` in browsers, `undefined` in strict mode), **not `person`**.

---

## **üîπ `this` in Arrow Functions (`=>`)**

- **Arrow functions do NOT create their own `this`.**
- Instead, they **inherit `this` from the surrounding (parent) function**.

### **‚úÖ Example 3: Fixing `this` with an Arrow Function**

```js
const person = {
    name: "Achyuth",
    greet: function() {
        setTimeout(() => {
            console.log("Hello, " + this.name);
        }, 1000);
    }
};

person.greet();  // "Hello, Achyuth"
```

‚úîÔ∏è **Here, `this` is inherited from `greet()`, which refers to `person`.**

---

### **üîπ Key Difference in Simple Terms**

|Feature|Regular Function (`function`)|Arrow Function (`=>`)|
|---|---|---|
|**How `this` Works**|Creates its own `this`|Inherits `this` from its surrounding function|
|**Inside Objects**|`this` refers to the object|`this` does NOT refer to the object|
|**Inside Callbacks (`setTimeout`, `map`)**|`this` may become `window` (or `undefined` in strict mode)|`this` stays the same as the outer function|

---

## **üöÄ Summary (For Beginners)**

‚úîÔ∏è **Regular functions (`function`) create their own `this`, so `this` changes based on how the function is called.**  
‚úîÔ∏è **Arrow functions (`=>`) do not have their own `this` ‚Äì they take `this` from where they are defined.**

üëâ **Use regular functions when defining object methods.**  
üëâ **Use arrow functions for callbacks (like `setTimeout`, `map`, `filter`) to avoid `this` issues.**


# **üöÄRest Operator (`...`) in JavaScript

The **rest operator (`...`)** allows a function to accept an **indefinite number of arguments** as an array. It is useful when working with functions that need to handle **multiple arguments dynamically**.

---

## **üîπ Syntax of Rest Operator**

```js
function myFunction(...restParams) {
    console.log(restParams);
}
```

- The `...` **rest operator** gathers multiple arguments into a **single array**.
- It **must be the last parameter** in the function.

---

## **üîπ Example 1: Using Rest Operator in Functions**

```js
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // Output: 15
console.log(sum(10, 20));        // Output: 30
```

‚úîÔ∏è **All arguments are stored in an array (`numbers`) and processed with `.reduce()`**.

---

## **üîπ Example 2: Rest Operator with Normal Parameters**

```js
function introduce(firstName, lastName, ...hobbies) {
    console.log(`Hi, I am ${firstName} ${lastName}.`);
    console.log(`My hobbies are: ${hobbies.join(", ")}`);
}

introduce("Achyuth", "J", "Coding", "Gaming", "Traveling");
/*
Output:
Hi, I am Achyuth J.
My hobbies are: Coding, Gaming, Traveling
*/
```

‚úîÔ∏è **First two parameters are assigned normally, while the rest are collected in an array (`hobbies`).**

---

## **üîπ Example 3: Rest Operator in Destructuring**

The rest operator can also be used to collect **remaining elements** when destructuring arrays or objects.

### **‚úÖ Rest in Array Destructuring**

```js
const numbers = [10, 20, 30, 40, 50];

const [first, second, ...rest] = numbers;
console.log(first);  // 10
console.log(second); // 20
console.log(rest);   // [30, 40, 50]
```

‚úîÔ∏è **First two elements are extracted, the rest go into an array.**

---

### **‚úÖ Rest in Object Destructuring**

```js
const person = {
    name: "Achyuth",
    age: 25,
    country: "India",
    profession: "Developer"
};

const { name, age, ...otherDetails } = person;
console.log(name);         // "Achyuth"
console.log(age);          // 25
console.log(otherDetails); // { country: "India", profession: "Developer" }
```

‚úîÔ∏è **Extracts `name` and `age`, while `otherDetails` holds remaining properties.**

---

## **üöÄ Key Points**

‚úîÔ∏è The **rest operator (`...`)** collects multiple arguments into an **array**.  
‚úîÔ∏è It **must be the last parameter** when used in functions.  
‚úîÔ∏è It works with **function arguments**, **array destructuring**, and **object destructuring**.  
‚úîÔ∏è **Different from the spread operator (`...`)**, which expands elements instead of collecting them.

# **üöÄSpread Operator (`...`) in JavaScript**

### **üîπ What is the Spread Operator?**

The **spread operator (`...`)** is used to **expand elements** of an array, object, or iterable into individual elements. It is useful for **copying, merging, and passing multiple values**.

---

## **üîπ 1. Spread in Arrays**

### ‚úÖ **Copying an Array (Shallow Copy)**

```js
const numbers = [1, 2, 3];
const copy = [...numbers];

console.log(copy); // Output: [1, 2, 3]
```

‚úîÔ∏è **Creates a new array** without modifying the original.

---

### ‚úÖ **Merging Arrays**

```js
const arr1 = [1, 2];
const arr2 = [3, 4];
const merged = [...arr1, ...arr2];

console.log(merged); // Output: [1, 2, 3, 4]
```

‚úîÔ∏è The spread operator **joins arrays without modifying them**.

---

### ‚úÖ **Adding Elements to an Array**

```js
const nums = [2, 3, 4];
const newNums = [1, ...nums, 5];

console.log(newNums); // Output: [1, 2, 3, 4, 5]
```

‚úîÔ∏è **Adds elements dynamically** without affecting the original array.

---

## **üîπ 2. Spread in Objects**

### ‚úÖ **Copying an Object (Shallow Copy)**

```js
const user = { name: "Achyuth", age: 25 };
const copyUser = { ...user };

console.log(copyUser); // Output: { name: "Achyuth", age: 25 }
```

‚úîÔ∏è **Creates a new object** without modifying the original.

---

### ‚úÖ **Merging Objects**

```js
const user = { name: "Achyuth" };
const details = { age: 25, city: "Kollam" };

const mergedUser = { ...user, ...details };

console.log(mergedUser); 
// Output: { name: "Achyuth", age: 25, city: "Kollam" }
```

‚úîÔ∏è **Combines multiple objects** into one.

---

### ‚úÖ **Overriding Properties**

```js
const user = { name: "Achyuth", age: 25 };
const updatedUser = { ...user, age: 26 }; // Overriding age

console.log(updatedUser); // Output: { name: "Achyuth", age: 26 }
```

‚úîÔ∏è **Later properties override earlier ones**.

---

## **üîπ 3. Spread in Function Arguments**

### ‚úÖ **Passing an Array as Arguments**

```js
const numbers = [10, 20, 30];

function sum(a, b, c) {
    return a + b + c;
}

console.log(sum(...numbers)); // Output: 60
```

‚úîÔ∏è The spread operator **expands the array into separate arguments**.

---

## **üîπ 4. Difference Between Spread (`...`) and Rest (`...`)**

|Feature|Spread (`...`)|Rest (`...`)|
|---|---|---|
|**Usage**|Expands elements|Gathers elements|
|**Where Used?**|Arrays, Objects, Function Arguments|Function Parameters|
|**Example**|`const copy = [...arr]`|`function sum(...nums) {}`|

‚úîÔ∏è **Spread extracts values, while Rest collects values!**

---

## **üöÄ Summary**

‚úîÔ∏è **Copies arrays & objects**  
‚úîÔ∏è **Merges arrays & objects**  
‚úîÔ∏è **Passes array values as function arguments**  
‚úîÔ∏è **Simplifies coding and improves readability**

Let me know if you need more details! üöÄ
# **üöÄDeep Copy vs Shallow Copy in JavaScript**

When copying objects or arrays in JavaScript, there are two types of copies: **shallow copy** and **deep copy**. Understanding the difference is important to avoid unintended changes in data.

---

## **üîπ What is a Shallow Copy?**

A **shallow copy** creates a new object, but it **copies only the reference** of nested objects or arrays.

- Changes in the original object's nested elements **will affect the copied object** (because they both point to the same reference).

### **‚úÖ Example of Shallow Copy**

```js
const original = {
    name: "Achyuth",
    details: {
        age: 25,
        city: "Kollam"
    }
};

// Creating a shallow copy using spread operator
const shallowCopy = { ...original };

// Modifying the nested object
shallowCopy.details.city = "Pattaya";

console.log(original.details.city);  // "Pattaya" (also changed!)
console.log(shallowCopy.details.city); // "Pattaya"
```

‚úîÔ∏è **The nested `details` object is still shared between `original` and `shallowCopy`**.  
‚ùå **Changing `shallowCopy.details.city` also changes `original.details.city`**.

### **üõ† Ways to Create a Shallow Copy**

- **Spread Operator (`{ ...obj }`)**
- **`Object.assign({}, obj)`**
- **`Array.prototype.slice()`** (for arrays)
- **`Array.prototype.concat()`** (for arrays)

---

## **üîπ What is a Deep Copy?**

A **deep copy** creates a completely independent copy, including all nested objects and arrays.

- Changes in the copied object **do not affect the original object**.

### **‚úÖ Example of Deep Copy**

```js
const original = {
    name: "Achyuth",
    details: {
        age: 25,
        city: "Kollam"
    }
};

// Creating a deep copy using JSON methods
const deepCopy = JSON.parse(JSON.stringify(original));

// Modifying the nested object
deepCopy.details.city = "Pattaya";

console.log(original.details.city);  // "Kollam" (unchanged)
console.log(deepCopy.details.city);  // "Pattaya"
```

‚úîÔ∏è **Now, modifying `deepCopy.details.city` does NOT affect `original.details.city`**.

### **üõ† Ways to Create a Deep Copy**

1. **`JSON.parse(JSON.stringify(obj))`** ‚úÖ (Simple, but loses functions & special values like `undefined`)
2. **Lodash's `cloneDeep(obj)`** ‚úÖ (Best for all data types)
3. **Recursion (Manually copying each property)** ‚úÖ (Flexible, but complex)
4. **Structured Clone API (`structuredClone(obj)`)** ‚úÖ (Best modern method, supports all types)

---

## **üîπ Key Differences**

|Feature|Shallow Copy|Deep Copy|
|---|---|---|
|**Nested Objects**|**Copied by reference** (shared)|**Completely cloned** (independent)|
|**Modification Effect**|Changes in nested elements affect both copies|Changes in one copy do not affect the other|
|**Methods**|`Object.assign()`, spread operator `{ ...obj }`|`JSON.parse(JSON.stringify())`, `structuredClone()`, `_.cloneDeep()`|

---

## **üöÄ Summary**

‚úîÔ∏è **Use shallow copy** when working with simple objects without nested structures.  
‚úîÔ∏è **Use deep copy** when you want to ensure that changes to the copy do not affect the original object.

# **üöÄObject Literals in JavaScript**

### **üîπ What Are Object Literals?**

Object literals are a simple way to create objects in JavaScript using curly braces `{}`. They store key-value pairs and are widely used for **structuring data**.

---

## **üîπ 1. Basic Object Literal Syntax**

```js
const person = {
    name: "Achyuth",
    age: 25,
    city: "Kollam"
};

console.log(person.name);  // Output: Achyuth
console.log(person.age);   // Output: 25
```

‚úîÔ∏è Uses `{ key: value }` format to create an object.

---

## **üîπ 2. Shorthand Property Names**

If a variable has the same name as a key, you can **omit** the key name.

```js
const name = "Achyuth";
const age = 25;

const user = { name, age }; // Same as { name: name, age: age }

console.log(user); // Output: { name: 'Achyuth', age: 25 }
```

‚úîÔ∏è **Shortens code** and makes it cleaner.

---

## **üîπ 3. Adding Methods to Objects**

```js
const user = {
    name: "Achyuth",
    greet() {  
        console.log(`Hello, my name is ${this.name}`);
    }
};

user.greet(); // Output: Hello, my name is Achyuth
```

‚úîÔ∏è **Method shorthand (`greet() {}`)** makes it concise.

---

## **üîπ 4. Computed Property Names**

You can use **dynamic keys** inside objects.

```js
const key = "score";

const student = {
    name: "Yadav",
    [key]: 95
};

console.log(student.score); // Output: 95
```

‚úîÔ∏è **Dynamically sets a key name using a variable**.

---

## **üîπ 5. Nesting Objects**

```js
const person = {
    name: "Mahindra",
    address: {
        city: "Pattaya",
        country: "Thailand"
    }
};

console.log(person.address.city); // Output: Pattaya
```

‚úîÔ∏è Objects **can contain other objects** inside them.

---

## **üîπ 6. Merging Objects with Spread (`...`)**

```js
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };

const merged = { ...obj1, ...obj2 };

console.log(merged); // Output: { a: 1, b: 2, c: 3, d: 4 }
```

‚úîÔ∏è **The spread operator (`...`) merges multiple objects**.

---

## **üîπ 7. Checking if a Key Exists**

```js
const user = { name: "Achyuth", age: 25 };

console.log("age" in user); // Output: true
console.log(user.hasOwnProperty("city")); // Output: false
```

‚úîÔ∏è **Use `"key" in object` or `hasOwnProperty()`** to check if a key exists.

---

## **üöÄ Summary**

‚úîÔ∏è **Object literals** make object creation simple  
‚úîÔ∏è Supports **shorthand properties** and **computed keys**  
‚úîÔ∏è Allows **methods, nesting, and merging**

# **üöÄArray Destructuring in JavaScript**

### **üîπ What is Array Destructuring?**

Array destructuring is a **quick way to extract values** from an array and assign them to variables in a **single line**.

---

## **üîπ 1. Basic Array Destructuring**

```js
const numbers = [10, 20, 30];

const [a, b, c] = numbers;

console.log(a); // Output: 10
console.log(b); // Output: 20
console.log(c); // Output: 30
```

‚úîÔ∏è Extracts values from the array **directly into variables**.

---

## **üîπ 2. Skipping Elements**

You can **skip** array elements by leaving an empty space.

```js
const numbers = [10, 20, 30, 40];

const [first, , third] = numbers;

console.log(first);  // Output: 10
console.log(third);  // Output: 30
```

‚úîÔ∏è The second element **(20)** is skipped.

---

## **üîπ 3. Default Values**

If an array doesn‚Äôt have enough elements, you can **set default values**.

```js
const numbers = [10];

const [a, b = 20, c = 30] = numbers;

console.log(a); // Output: 10
console.log(b); // Output: 20 (default used)
console.log(c); // Output: 30 (default used)
```

‚úîÔ∏è **Default values** are used **when no value is available**.

---

## **üîπ 4. Swapping Variables Without a Temporary Variable**

```js
let x = 5, y = 10;

[x, y] = [y, x]; // Swap values

console.log(x); // Output: 10
console.log(y); // Output: 5
```

‚úîÔ∏è **No need for a temporary variable!** Just use destructuring.

---

## **üîπ 5. Destructuring with Rest (`...`) Operator**

You can use the **rest operator (`...`)** to collect the remaining elements into an array.

```js
const numbers = [1, 2, 3, 4, 5];

const [first, second, ...rest] = numbers;

console.log(first);  // Output: 1
console.log(second); // Output: 2
console.log(rest);   // Output: [3, 4, 5]
```

‚úîÔ∏è The `rest` variable **collects the remaining values** as an array.

---

## **üîπ 6. Nested Array Destructuring**

```js
const colors = [["red", "green"], ["blue", "yellow"]];

const [[firstColor, secondColor], [thirdColor]] = colors;

console.log(firstColor);  // Output: red
console.log(thirdColor);  // Output: blue
```

‚úîÔ∏è Destructuring **works with nested arrays** too!

---

## **üöÄ Summary**

‚úîÔ∏è Extracts **array elements into variables easily**  
‚úîÔ∏è Supports **skipping elements & default values**  
‚úîÔ∏è Helps in **swapping variables & working with rest (`...`)**  
‚úîÔ∏è **Works with nested arrays**

# **üöÄObject Destructuring in JavaScript**

### **üîπ What is Object Destructuring?**

Object destructuring is a **quick way to extract values** from objects and assign them to variables in a **single step**.

---

## **üîπ 1. Basic Object Destructuring**

```js
const person = { name: "Achyuth", age: 25, city: "Kollam" };

const { name, age, city } = person;

console.log(name); // Output: Achyuth
console.log(age);  // Output: 25
console.log(city); // Output: Kollam
```

‚úîÔ∏è **Extracts object properties into variables** with the **same names**.

---

## **üîπ 2. Changing Variable Names**

You can rename properties while destructuring.

```js
const person = { name: "Achyuth", age: 25 };

const { name: fullName, age: years } = person;

console.log(fullName); // Output: Achyuth
console.log(years);    // Output: 25
```

‚úîÔ∏è **`name` is stored as `fullName`, `age` as `years`**.

---

## **üîπ 3. Default Values**

If a property is **missing**, you can assign a **default value**.

```js
const user = { name: "Achyuth" };

const { name, age = 30 } = user;

console.log(name); // Output: Achyuth
console.log(age);  // Output: 30 (default used)
```

‚úîÔ∏è If `age` doesn‚Äôt exist in `user`, it defaults to `30`.

---

## **üîπ 4. Nested Object Destructuring**

You can extract **nested object properties**.

```js
const person = {
    name: "Achyuth",
    address: { city: "Pattaya", country: "Thailand" }
};

const { address: { city, country } } = person;

console.log(city);    // Output: Pattaya
console.log(country); // Output: Thailand
```

‚úîÔ∏è **Directly accesses nested properties** without needing `person.address.city`.

---

## **üîπ 5. Using Rest (`...`) with Object Destructuring**

```js
const user = { name: "Achyuth", age: 25, city: "Kollam", country: "India" };

const { name, age, ...rest } = user;

console.log(name); // Output: Achyuth
console.log(age);  // Output: 25
console.log(rest); // Output: { city: "Kollam", country: "India" }
```

‚úîÔ∏è `...rest` **gathers remaining properties** into an object.

---

## **üîπ 6. Destructuring in Function Parameters**

You can **directly extract object properties** inside function parameters.

```js
function displayUser({ name, age }) {
    console.log(`Name: ${name}, Age: ${age}`);
}

const user = { name: "Achyuth", age: 25, city: "Kollam" };

displayUser(user); // Output: Name: Achyuth, Age: 25
```

‚úîÔ∏è **No need to access `user.name` or `user.age` separately**.

---

## **üöÄ Summary**

‚úîÔ∏è **Extracts object properties into variables**  
‚úîÔ∏è Supports **renaming, default values, and rest (`...`)**  
‚úîÔ∏è Works with **nested objects**  
‚úîÔ∏è **Simplifies function parameters**

Let me know if you need more details! üöÄ




